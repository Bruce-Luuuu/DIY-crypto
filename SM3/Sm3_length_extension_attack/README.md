## Implement length extension attack for SM3, SHA256, etc.

### 项目简介

由于 SM3、SHA256 等都是 Merkle-Damgard 结构的哈希函数，而长度扩展攻击是针对 MD 结构的常见攻击，此项目就是要实现对 SM3 的长度扩展攻击。

对于一般 MD 结构的哈希函数，长度扩展攻击的原理为：给定杂凑值 $H(M)$ 和消息的长度 $|M|$，无需知道消息 $M$ ，令 $z= 0^d~\|~|M|~ \|~x$，其中 $0^d~\|~|M|$ 为原始消息 $M$ 的填充信息（一般为消息长度），$x$ 为敌手任意选择的消息，则根据 $H(M)$ 可计算 $h^′$,满足 $H(M||z)=h'$。具体过程如下图所示：

<img src="https://s1.ax1x.com/2022/07/30/vFZCU1.png" alt="vFZCU1.png" width="490px" />

<img src="https://s1.ax1x.com/2022/07/30/vFZP4x.png" alt="vFZP4x.png" width="530px" />

### 代码说明

- 代码文件：`main.cpp`	`SM3.cpp `	`SM3.hpp`
- 实现思路：这里主要针对 SM3 长度扩展攻击的实现而介绍，更具体的代码实现细节见代码注释。SM3 的消息分组长度为 512 bit，在处理最后一个分块时，先在分块末尾填充 1 比特 '1'，然后填充 0，直到该分组长度达到 448 bit 剩下的 64 bit 为消息长度的 2 进制表示。因此先生成长度为 55 Bytes 的消息 M 作为未知的初始消息，计算 h = hash(M) 后，构造 z = '100...00' + bin(55) + M1, 为了伪造出 hash(M+z)，使用 h 作为初始向量计算 h' = hash(M1)，注意这里 M1 需要自己“手动”填充至 512 bit（因为最后长度的编码应该是 M+pad+M1 的总长度），这样，h‘ 就成为我们伪造的 hash(M+z) 的值。
- 在实现时要注意 CPU 大端小端的问题。

### 运行指导

在存在 Visual Studio 软件开发环境条件下，双击 `.sln` 文件加载整个项目文件，然后直接编译运行即可（推荐在 Release 模式下编译，如果平台是64位则选择 x64，否则 x86）。

### 运行结果

<img src="https://s1.ax1x.com/2022/07/30/vFZmbd.png" alt="vFZmbd.png" width="1000px" />

这里消息$~M~$和消息$~M_1~$的长度都是 55 字节，这样方便在添加一个字节 '10000000' 后剩下的 8 个字节存放消息长度的编码。

可以看到使用 $\mathtt{hash}(M)$ 作为 $\mathbf{IV}$ 伪造出的 $\mathtt{hash}(M1)$ 与目标 $\mathtt{hash}(M\|pad\|M_1)$ 的值相同，说明长度扩展攻击实施成功。



### 参考引用

此项目中 SM3 代码参考《商用密码 算法原理与C语言实现》一书补充改编而成；长度扩展攻击无参考，按照自己的理解实现。